# 自动化构建

一切重复工作本应自动化

- 自动化：通过机器代替手工完成一些工作。
- 构建：把一个东西转换成另一个东西。

开发阶段写出的源代码，自动化转换成生产环境中可以运行的代码或程序。

一般将这个过程称为 **自动化构建工作流**。

- 脱离运行环境兼容带来的问题
- 开发阶段使用提高效率的语法、规范和标准
- 构建转换那些不被支持的**特性**(ES6+,SASS等)

## npm scripts

定义一些与项目开发过程有关的脚本命令。

scripts可以自动发现`node_modules`里面的命令（可以省略`.\node_modules\.bin\`）。

它是实现自动化构建工作流最简单的方式。

### 钩子机制

可以监听一些命令的声明周期，并在那个时间点执行指定命令。例如`preserve`在`serve`命令执行前执行。

## 简单案例 SASS构建CSS

代码目录 `/notes/note_code/sass-to-css`

### 安装sass

`yarn sass --dev`

### 使用sass命令转化.scss文件

`.\node_modules\.bin\sass scss/main.css css/style.css`

### npm scripts包装构建命令

package.json

```json
{
  "scripts": {
    "build": "sass scss/main.scss css/style.css"
  }
}
```

运行（yarn可以省略run）：

```node
npm run build
yarn build
```

### 安装browser-sync

`yarn add browser-sync --dev`

该模块用于启动一个测试服务器，以运行项目。

#### 添加serve命令

```json
{
  "scripts": {
    "build": "sass scss/main.scss css/style.css",
    "serve": "browser-sync ."
  }
}
```

#### 运行

`yarn serve`

#### 借助npm scripts的钩子机制

项目中页面正常浏览需在scss转化为css后，借助scripts的钩子机制，实现在运行serve命令前执行build命令。

添加`preserve`命令

```json
{
  "scripts": {
    "build": "sass scss/main.scss css/style.css",
    "preserve": "yarn build",
    "serve": "browser-sync ."
  }
}
```

### 监听scss文件

使用`--watch`参数，监听scss文件的修改，实时自动编译。

```json
{
  "scripts": {
    "build": "sass scss/main.scss css/style.css --watch",
    "preserve": "yarn build",
    "serve": "browser-sync ."
  }
}
```

### 同时执行多个命令

监听命令阻塞了后面的serve命令，安装`yarn add npm-run-all --dev`模块实现同时执行多个命令（通过模块的`run-p`命令
）。

注：需删除script对serve的监听命令`preserve`

```json
{
  "scripts": {
    "build": "sass scss/main.scss css/style.css --watch",
    "serve": "browser-sync .",
    "start": "run-p build serve"
  }
}
```

### 监听同步文件变化到浏览器

使用`--files`参数，使`browser-sync`监听文件的变化，并将变化自动同步到浏览器，避免重复的手动刷新浏览器。

```json
{
  "scripts": {
    "build": "sass scss/main.scss css/style.css --watch",
    "serve": "browser-sync . --files \"css/*.css\"",
    "start": "run-p build serve"
  }
}
```

## 常用的自动化构建工具

- Grunt
  - 最早的工具，鼻祖
  - 基于临时文件工作，大量磁盘读写操作，构建速度较慢
  - 几乎退出历史舞台
- Gulp
  - 基于内存实现，相对磁盘读写，速度快很多
  - 支持同时执行多个任务
  - 当前主流
- FIS
  - 百度前端团队推出的构建系统
  - 更像是捆绑套餐，集成很多功能
  - 更易上手，灵活度差

严格来说 webpack 是一个模块打包工具。

## Grunt

### 基本使用

安装 `yarn add grunt`

添加grunt入口文件 `gruntfile.js`

- 用于定义一些grunt自动执行的任务
- 需要导出一个函数
- 函数接收一个grunt的参数，内部提供一些创建任务时可以用到的API

```js
module.exports = grunt => {
  // 创建任务

  // 用法1：registerTask(taskName[任务名], fn[任务发生时执行的函数])
  grunt.registerTask('foo', () => {
    console.log('hello grunt');
  })
  
  // 用法2：registerTask(taskName[任务名], description[任务描述] fn[任务发生时执行的函数])
  // 任务描述会出现在grunt任务的帮助信息中
  // yarn grunt --help
  // Available tasts中显示
  grunt.registerTask('bar', '任务描述', () => {
    console.log('other task');
  })

  // 用法3：registerTask('default', fn[任务发生时执行的函数])
  // 任务名为default时，该任务会成为grunt的默认任务
  // 运行这个任务时不需要指定任务名称
  // grunt.registerTask('default', () => {
  //   console.log('default task');
  // })

  // 用法4：registerTask('default', taskList[任务列表：Array])
  // 一般会用default映射一些其他的任务
  // 依次执行参数2数组中的任务
  grunt.registerTask('default', ['foo', 'bar'])
}
```

执行任务`yarn grunt foo`

查看grunt帮助信息`yarn grunt --help`

执行默认任务`yarn grunt`

### 异步任务支持（标记任务成功）

Grunt代码默认支持同步模式。

如果需要异步操作，必须要使用`this.async()`方法得到一个回调函数，在异步操作完成之后去调用这个回调函数，标识任务已经完成，grunt才会结束这个任务的执行。

- 使用`this`的话不能使用箭头函数。
- 异步任务在任务列表中，后面的任务要等异步任务执行完才会执行。

```js
module.exports = grunt => {
  // grunt.registerTask('async-task', () => {
  //   setTimeout(() => {
  //     // 输出不会执行
  //     console.log('async task working')
  //   }, 1000)
  // })

  grunt.registerTask('async-task', function() {
    const done = this.async()
    setTimeout(() => {
      console.log('async task working');
      done() // 标识任务完成
    }, 1000);
  })
}
```

### 标记任务失败

如果在任务执行中，需要的文件找不到了，此时可以将任务标记为失败的任务。

在函数体中`return false`来实现。

如果这个任务在任务列表中，任务的失败将导致后面的任务不再被执行。

添加`--force`参数（`yarn grunt <task name> --force`），使任务强制执行，不影响后面任务的执行。

```js
module.exports = grunt => {
  grunt.registerTask('bad', () => {
    console.log('bad working');
    return false
  })

  grunt.registerTask('foo', () => {
    console.log('foo task');
  })

  grunt.registerTask('bar', () => {
    console.log('bar task');
  })

  // bar不会被执行
  grunt.registerTask('default', ['foo', 'bad', 'bar'])
}
```

#### 异步任务标记失败

给`this.async()`方法返回的回调函数，传入一个`false`实参即可。

```js
module.exports = grunt => {
  grunt.registerTask('bad-async', function () {
    const done = this.async()
    setTimeout(() => {
      console.log('bad-async working')
      done(false)
    }, 1000);
  })

  grunt.registerTask('foo', () => {
    console.log('foo task')
  })
  grunt.registerTask('bar', () => {
    console.log('bar task')
  })

  grunt.registerTask('default', ['foo', 'bad-async', 'bar'])
}
```

### 配置选项方法

grunt还提供一个用于添加一些配置选项的API`initConfig`。

例如定义压缩任务时，配置需要压缩的文件路径。

```js
module.exports = grunt => {
  // initConfig() 接收一个对象，key为配置名，value为任意类型的数据
  // 一般将属性名定义为与任务同名
  grunt.initConfig({
    config1: 'this is config1',
    config2: {
      bar: 'this is config2.bar'
    }
  })

  grunt.registerTask('foo', () => {
    // config方法获取配置
    console.log(grunt.config('config1'))
    console.log(grunt.config('config2.bar'))
    console.log(grunt.config('config2').bar)
  })
}
```

### 多目标任务

多目标模式，可以让任务根据配置形成多个子任务。

使用`registerMultiTask`创建多目标任务。

运行任务会报错`No "<task name>" targets found.`，提示没有配置对应的目标

使用`initConfig`为多目标任务配置目标（属性名=任务名）

运行任务

`yarn grunt <task name>` 会同时执行每个目标，相当于以两个子任务的形式去运行

`yarn grunt <task name>:<target name>` 单独执行指定目标

```js
module.exports = grunt => {
  grunt.initConfig({
    build: {
      // key为目标名称
      // 在build当中指定的每一个属性的key都会称为build这个任务的目标，除了options
      css: 'target-css',
      js: 'target-js',

      // options会作为任务的配置选项出现
      options: {
        foo: 'this is foo'
      },
      html: {
        // 也可以为每个目标定义options属性，用于覆盖任务的配置选项
        options: {
          foo: 'this foo from target-html',
          elseInfo: 'target-html'
        }
      }
    }
  })

  grunt.registerMultiTask('build', function () {
    // 可以通过this拿到目标的信息，和options配置信息
    console.log(`target:${this.target}, data: ${this.data}`)
    console.log(this.options());
  })
}
```

### 插件使用

插件机制是grunt的核心，插件封装了一些通用的构建任务。

一般grunt插件命名规范是`grunt[-contrib]-<task name>`

1. npm安装插件
2. gruntfile.js中载入插件提供的一些任务
3. 根据插件文档完成相关的配置选项

示例：

```js
module.exports = grunt => {
  // grunt-contrib-clean 插件用于自动清除开发中产生的临时文件
  // clean是任务名，该任务是一个多目标任务，需要配置目标
  
  // 配置目标
  grunt.initConfig({
    clean: {
      // key：目标，value：目标所要清除的文件路径
      temp: 'temp/app.js',
      // 通配符方式
      temp2: 'temp/*.txt'
      // ** 表示所有目录及目录下的文件
      temp3: 'temp/**'
    }
  })

  // 加载插件即可使用 yarn grunt clean执行任务
  grunt.loadNpmTasks('grunt-contrib-clean')
}
```

### grunt常用插件

代码目录 `/notes/note_code/grunt-plugins`

1. grunt-sass 编译sass，需安装编译模块`sass`
2. grunt-babel 编译ES6语法，需安装编译模块及预设`@babel/core @babel/preset-env`
3. grunt-contrib-watch 监听文件改动，自动编译
   1. watch 不会执行首次的任务，只会在监听文件变化后执行，所以需要手动执行下编译任务，例如配置默认default任务，包含编译任务以及watch任务

`load-grunt-tasts`模块解决重复使用`loadNpmTasks`载入插件的操作。

## Gulp



###



